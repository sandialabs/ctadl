#pragma once

// MatchPrefix cases
// these cases are split based on if none, one, or two access paths are empty

// the tests for CisAccessPath in C2 and C3 are redundant but they make writing
// plans easier

#define MatchPrefixCase0(p12, p1, p2) AccessPathNonEmptySplit(p12, p1, p2)
#define MatchPrefixCase1(p12, p1, p2) p1="", p2!="", p12=p2, CisAccessPath(p12)
#define MatchPrefixCase2(p12, p1, p2) p2="", p1!="", p12=p1, CisAccessPath(p12)
#define MatchPrefixCase3(p12, p1, p2) p1="", p2="", p12="", CisAccessPath("")

#define MatchComputedPrefixCase0(p12, p1, p2) p1!="", p2!="", p12 !="", ComputedAccessPathNonEmptySplit(p12, p1, p2)
#define MatchComputedPrefixCase1(p12, p1, p2) p1="", p2!="", p12=p2, isComputedAccessPath(p12)
#define MatchComputedPrefixCase2(p12, p1, p2) p2="", p1!="", p12=p1, isComputedAccessPath(p12)
#define MatchComputedPrefixCase3(p12, p1, p2) p1="", p2="", p12="", isComputedAccessPath("")

// There is a pattern in summary instantiation where we have to do two MatchComputedPrefix.
// It looks like:
//
//   MatchComputedPrefix(to_path, to_actual_path, to_summary_path),
//   MatchComputedPrefix(from_path, from_actual_path, from_summary_path)
//
// The actual_paths comes from CCall_ActualParam. The summary_paths come from SummaryFlow.
//
// Writing this literally both generates rules that never fire and it's impossible to write plans for them.
// The rules that don't fire are because of contradictions between cases generated by MatchComputedPrefix.
// For instance, if the to_actual_path is empty and the to_summary_path is
// nonempty, then the case where to_path is also empty simply can't fire.
// The full explosion looks like this where af = from_actual_path, at =
// to_actual_path, sf = from_summary_path, st = to_summary_path. - means empty and * means non-empty.
//
// af at sf st
// -  -  -  -  A
// -  -  -  *  B
// -  -  *  -  C
// -  -  *  *  D
// -  *  -  -  E
// -  *  -  *  F
// -  *  *  -  G
// -  *  *  *  H
// *  -  -  -  I
// *  -  -  *  J
// *  -  *  -  K
// *  -  *  *  L
// *  *  -  -  M
// *  *  -  *  N
// *  *  *  -  O
// *  *  *  *  P
//
// We can group these into three cases:
// - FROM has at least one empty path and TO has at least one empty path
// - FROM has at least one empty path but TO are nonempty and TO has at least one empty path but FROM are nonempty
// - both are nonempty
// This case analysis turns all the cases
// A B C D E F G H I J M N
// into
// K L O P
// So I've split them into plannable cases below.

// no relations
#define ActualToFormalComputedPrefixCase0( \
        to_path, to_actual_path, to_summary_path, \
        from_path, from_actual_path, from_summary_path) (\
    (from_actual_path = ""; from_summary_path = ""), \
    oecat(from_path, from_actual_path, from_summary_path), \
    (to_actual_path = ""; to_summary_path = ""), \
    oecat(to_path, to_actual_path, to_summary_path) \
    )

// 1 relation
#define ActualToFormalComputedPrefixCase1( \
        to_path, to_actual_path, to_summary_path, \
        from_path, from_actual_path, from_summary_path) \
    ( \
        ComputedAccessPathNonEmptySplit(from_path, from_actual_path, from_summary_path), \
        (to_actual_path = ""; to_summary_path = ""), \
        oecat(to_path, to_actual_path, to_summary_path) \
    ; \
        ComputedAccessPathNonEmptySplit(to_path, to_actual_path, to_summary_path), \
        (from_actual_path = ""; from_summary_path = ""), \
        oecat(from_path, from_actual_path, from_summary_path), \
        from_path = from_actual_path \
    )

// 2 relations
#define ActualToFormalComputedPrefixCase2( \
        to_path, to_actual_path, to_summary_path, \
        from_path, from_actual_path, from_summary_path) (\
    ComputedAccessPathNonEmptySplit(to_path, to_actual_path, to_summary_path), \
    ComputedAccessPathNonEmptySplit(from_path, from_actual_path, from_summary_path) \
    )


.decl MatchPrefix(to_split:CAccessPath, prefix:CAccessPath, suffix:CAccessPath) inline
MatchPrefix(to_split, prefix, suffix) :-
    MatchPrefixCase0(to_split, prefix, suffix);
    MatchPrefixCase1(to_split, prefix, suffix);
    MatchPrefixCase2(to_split, prefix, suffix);
    MatchPrefixCase3(to_split, prefix, suffix).

.decl MatchComputedPrefix(to_split:CAccessPath, prefix:CAccessPath, suffix:CAccessPath) inline
MatchComputedPrefix(to_split, prefix, suffix) :-
    MatchComputedPrefixCase0(to_split, prefix, suffix);
    MatchComputedPrefixCase1(to_split, prefix, suffix);
    MatchComputedPrefixCase2(to_split, prefix, suffix);
    MatchComputedPrefixCase3(to_split, prefix, suffix).

// get a suffix of a path given a path and a prefix
.decl MatchStringPrefix(to_split: symbol, prefix: symbol, suffix: symbol) inline
MatchStringPrefix(to_split, prefix, suffix) :-
  substr(to_split, 0, strlen(prefix)) = prefix,
  suffix = substr(to_split, strlen(prefix), strlen(to_split) - strlen(prefix)).

.decl AccessPathNonEmptySplit(to_split:CAccessPath, prefix:CAccessPath, suffix:CAccessPath)
.decl DotIndex(ap: CAccessPath, index: number)

// implementation of splitting access paths, either on every possible split or
// on ones that split existing aps

DotIndex(ap, i) :-
    CisAccessPath(ap),
    strlen(ap) >= 3,
    i = range(2, strlen(ap)-1),
    substr(ap, i, 1) = ".".

// every possible split
AccessPathNonEmptySplit(ap, prefix, suffix) :-
    DotIndex(ap, i),
    prefix = substr(ap, 0, i),
    suffix = substr(ap, i, strlen(ap)-i+1),
    CisAccessPath(prefix),
    // Same filter as below.
    !contains(STAR, suffix).

#ifdef ALL_OUTPUTS
.output AccessPathNonEmptySplit(CTADL_OUTPUT_DB_IO)
#endif


.decl ComputedAccessPathNonEmptySplit(to_split:CAccessPath, prefix:CAccessPath, suffix:CAccessPath)
.decl ComputedDotIndex(ap: CAccessPath, index: number)
ComputedDotIndex(ap, i) :-
    isComputedAccessPath(ap),
    strlen(ap) >= 3,
    i = range(2, strlen(ap)-1),
    substr(ap, i, 1) = ".".

ComputedAccessPathNonEmptySplit(ap, prefix, suffix) :-
    ComputedDotIndex(ap, i),
    prefix = substr(ap, 0, i),
    suffix = substr(ap, i, strlen(ap)-i+1),
    isComputedAccessPath(prefix),
    // Filters out .* paths because they shouldn't be propagated. They can be
    // *introduced* with abstraction and they can be *matched* with matching
    // rules but they shouldn' be propagation with star rules or with fieldprop
    // rules. Propagatiing them leads to a proliferation of badness.
    !contains(STAR, suffix).

CTADLStats("AccessPathNonEmptySplit", n) :- n = count : { AccessPathNonEmptySplit(_, _, _) }.
CTADLStats("ComputedAccessPathNonEmptySplit", n) :- n = count : { ComputedAccessPathNonEmptySplit(_, _, _) }.
